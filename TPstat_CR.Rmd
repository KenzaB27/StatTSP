---
title: "TP Statistique"
author: "BOUZID Kenza, JEANNE Nathan, CANNEDDU Hugo"
date: "1 avril 2020"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
set.seed(287)
knitr::opts_chunk$set(echo = TRUE)

## il est possible qu'avant d'installer le package TSPpackage vous deviez installer ou ré-installer Rcpp
#install.packages('Rcpp')

# install.packages('./TSPpackage_1.0.tar.gz',repos=NULL,type='bin') ## pour linux
# install.packages('./TSPpackage_1.0.zip',repos=NULL,type='bin')    ## pour windows
## je ne peux pas fournir de package pour mac...

## Appels aux packages, après les avoir installés !
library(sp)
library(maps)
library(microbenchmark)
library(TSP)
library(TSPpackage)
```
Voici le plan de ce qui sera fait dans le TP.

# 0. Visualisation de chemins

Lecture du fichier des villes :

```{r, echo=TRUE}
villes <- read.csv('DonneesGPSvilles.csv',header=TRUE,dec='.',sep=';',quote="\"")
str(villes)
```
Représentation des chemins par plus proches voisins et du chemin optimal :
```{r, echo=TRUE}
coord <- cbind(villes$longitude,villes$latitude)
dist <- distanceGPS(coord)
voisins <- TSPnearest(dist)

pathOpt <- c(1,8,9,4,21,13,7,10,3,17,16,20,6,19,15,18,11,5,22,14,12,2)

par(mfrow=c(1,2),mar=c(1,1,2,1))
plotTrace(coord[voisins$chemin,], title='Plus proches voisins')
plotTrace(coord[pathOpt,], title='Chemin optimal')
```


Les longueurs des trajets (à vol d'oiseau) valent respectivement, pour la méthode des plus proches voisins :
```{r, echo=FALSE}
voisins$longueur
```
et pour la méthode optimale :
```{r, echo=FALSE}
calculeLongueur(dist,pathOpt)
```

Ceci illustre bien l'intérêt d'un algorithme de voyageur de commerce. Nous allons dans la suite étudier les performances de cet algorithme.


# 1. Comparaison d'algorithmes

Nombre de sommets fixes et graphes "identiques".

```{r, echo=TRUE}
      n <- 10
sommets <- data.frame(x = runif(n), y = runif(n))
  couts <- distance(sommets)
```

## 1.1. Longueur des chemins

Comparaison des longueurs de différentes méthodes : 

   * boxplots
   
```{r, echo=FALSE}
  X1 <- vector(mode="integer", length=50)
  X2 <- vector(mode="integer", length=50)
  X3 <- vector(mode="integer", length=50)
  X4 <- vector(mode="integer", length=50)
  X5 <- vector(mode="integer", length=50)
  n <-10
  for(i in 1:50)
  {
    sommets <- data.frame(x = runif(n), y = runif(n))
    couts <- distance(sommets)
    v1<-TSPbranch(couts)
    v2<-TSPnearest(couts)
    v3<-TSPsolve(couts, "repetitive_nn")
    v4<-TSPsolve(couts, "farthest_insertion")
    v5<-TSPsolve(couts, "two_opt")
    X1[i]<-v1
    X2[i]<-v2$longueur
    X3[i]<-v3
    X4[i]<-v4
    X5[i]<-v5
  }
  
  U1 <- rnorm(100)
  U2 <- rnorm(100,5)
  U3 <- rnorm(100,0,8)
  U4 <- rnorm(100,10)
  U5 <- rnorm(100,10,3)
  
  
  mat <- cbind(X1,X2,X3,X4,X5)
  par(mfrow=c(1,1))
  boxplot(mat,notch=TRUE)
```   
#TODO : Commenter le diagramme a moustaches (hihi)


   * test entre 'nearest' et 'branch'
   
   

   * tests 2 à 2 
```{r, echo=FALSE}
results<- c(X1,X2,X3,X4,X5)
methods<- c(rep("branch", 50),rep("nearest", 50),rep("repetitive_nn", 50),rep("farthest_insertion", 50),rep("two_opt", 50))

pairwise.t.test(results,methods,adjust.method="bonferroni")
```
#TODO : conclure 
# Note : Si la p-value est 1, 100% de chance que ????

## 1.2. Temps de calcul

Comparaison des temps à l'aide du package microbenchmark.

Exemple d'application de microbenchmark :
```{r, echo=TRUE}
microbenchmark(sqrt(x),x^0.5, times=100, setup={x <- runif(1)})
```

# 2. Etude e la complexité de l'algorithme Branch and Bound

## 2.1. Comportement par rapport au nombre de sommets : premier modèle

Récupération du temps sur 10 graphes pour différentes valeurs de $n$.

Ajustement du modèle linéaire de $\log(temps)^2$ en fonction de $n$.

Analyse de la validité du modèle : 

  * pertinence des coefficients et du modèle, 
  
  * étude des hypothèses sur les résidus.

## 2.2. Comportement par rapport au nombre de sommets : étude du comportement moyen

Récupération du temps moyen.

Ajustement du modèle linéaire de $\log(temps.moy)^2$ en fonction de $n$.

Analyse de la validité du modèle : 

  * pertinence des coefficients et du modèle, 
  
  * étude des hypothèses sur les résidus.
  

## 2.3. Comportement par rapport à la structure du graphe

Lecture du fichier 'DonneesTSP.csv'.

Ajustement du modèle linéaire de $\log(temps.moy)^2$ en fonction de toutes les variables présentes. Modèle sans constante.

Mise en \oe uvre d'une sélection de variables pour ne garder que les variables pertinentes.

Analyse de la validité du modèle : 

  * pertinence des coefficients et du modèle, 
  
  * étude des hypothèses sur les résidus.

